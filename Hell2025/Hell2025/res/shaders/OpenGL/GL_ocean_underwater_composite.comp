#version 430 core
#include "../common/constants.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(rgba16f, binding = 0) uniform image2D LightingImage; // output
layout (binding = 1) uniform sampler2D UnderwaterMaskTexture;
layout (binding = 2) uniform sampler2D GaussianFinalLighting;
layout (binding = 3) uniform sampler2D WaterColorTexture;
layout (binding = 4) uniform sampler2D WorldPositionTexture;
layout (binding = 5) uniform sampler2D NormalsTexture;
layout (binding = 6) uniform sampler2D WaterWorldPositionTexture;
layout (binding = 7) uniform sampler2D WaterDUDVTexture;

uniform float u_time;
uniform vec3 u_viewPos;
uniform mat4 u_inverseProjectionView;
uniform vec2 u_resolution;

vec3 GetWorldRay(vec2 fragCoord, vec2 resolution, mat4 inverseProjectionView, vec3 viewPos) {
    vec2 ndc = (fragCoord / resolution) * 2.0 - 1.0;
    vec4 clip = vec4(ndc, 1.0, 1.0);
    vec4 world = inverseProjectionView * clip;
    world /= world.w;
    return normalize(world.xyz - viewPos);
}

void main() {
    //return;
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 outputImageSize = imageSize(LightingImage);

    if (pixelCoords.x >= outputImageSize.x || pixelCoords.y >= outputImageSize.y) {
        return;
    }

    vec2 uv_screenspace = (vec2(pixelCoords) + 0.5) / vec2(outputImageSize);

    // Early-out FIRST: avoid all other work for non-underwater pixels.
    float underwaterMask = texture(UnderwaterMaskTexture, uv_screenspace).r;

    // Non water
    if (underwaterMask == 0.0) {
        return;
    }

    // Ocean surface
    if (underwaterMask > 0.75) {
        return;
    }


    vec3 waterColor = texture(WaterColorTexture, uv_screenspace).rgb;
    vec3 Normal = texture(NormalsTexture, uv_screenspace).xyz;
    vec3 waterWorldPos = texture(WaterWorldPositionTexture, uv_screenspace).xyz;

    // World ray fog (only needed for underwater work)
    vec3 rayDir = GetWorldRay(vec2(pixelCoords), u_resolution, u_inverseProjectionView, u_viewPos);
    vec3 down = vec3(0.0, -1.0, 0.0);
    float downwardness = clamp(dot(rayDir, down), 0.0, 1.0);
    float darknessCurve = 0.95;
    float darkness = mix(1.0, 0.0, pow(downwardness, darknessCurve));
    vec3 finalRayFog = vec3(0.4, 0.8, 0.6) * darkness * 0.00125;

    // Refraction distortion
    const float distortionSpeed = 0.05;
    const float distortionFactor = 0.0024;
    float offsetX = fract(u_time * distortionSpeed);
    vec2 uv_dudv = uv_screenspace + vec2(offsetX, 0.0);
    vec2 distortion = texture(WaterDUDVTexture, uv_dudv).rg * 2.0 - 1.0;

    vec2 uv_refraction = uv_screenspace + (distortion * distortionFactor);
    uv_refraction = clamp(uv_refraction, vec2(0.0), vec2(1.0));

    vec3 refactoredFinalLighting = texture(GaussianFinalLighting, uv_refraction).rgb;

    // Mix in water tint
    vec3 hack = refactoredFinalLighting * UNDER_WATER_TINT * 1.5;
    refactoredFinalLighting = mix(hack, refactoredFinalLighting, 0.5);

    // Above water skybox
    // NOTE: exact float equality checks can be flakyor.
    if (waterWorldPos != vec3(0.0)) {
        vec3 color = refactoredFinalLighting.rgb + (waterColor * waterColor * 10.0);
        color = refactoredFinalLighting.rgb + (waterColor * 1.0);
        imageStore(LightingImage, pixelCoords, vec4(color, 1.0));
        return;
    }

    // Underwater color
    vec3 color = refactoredFinalLighting.rgb;
    color = mix(color, color * UNDER_WATER_TINT, 0.15);

    // Hack to apply more water color to pixels under water.. rethink this
    if (waterWorldPos.y < 1.0) {
        color = mix(color, color * UNDER_WATER_TINT * UNDER_WATER_TINT, 0.9);
    }

    color -= finalRayFog;
    color *= 0.5;

    imageStore(LightingImage, pixelCoords, vec4(color, 1.0));
}

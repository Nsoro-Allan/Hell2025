#version 460

#include "../common/lighting.glsl"
#include "../common/post_processing.glsl"
#include "../common/types.glsl"
#include "../common/util.glsl"

layout(local_size_x = TILE_SIZE, local_size_y = TILE_SIZE, local_size_z = 1) in;

layout(rgba16f, binding = 0) uniform image2D LightingImage;

layout (binding = 1) uniform sampler2D BaseColorTexture;
layout (binding = 2) uniform sampler2D NormalTexture;
layout (binding = 3) uniform sampler2D RMATexture;
layout (binding = 4) uniform sampler2D WorldPositionTexture;
layout (binding = 5) uniform sampler2D DownsizedLightingTexture;
layout (binding = 6) uniform sampler2D ViewSpaceDepthTexture;

readonly restrict layout(std430, binding = 1) buffer rendererDataBuffer {
    RendererData rendererData;
};

readonly restrict layout(std430, binding = 2) buffer viewportDataBuffer {
    ViewportData viewportData[];
};

uniform float u_maxRayDistance = 10.0;
uniform int u_minSteps = 24; // The higher the floor, the better the result
uniform int u_maxSteps = 100; // The higher the upper, the better the result
uniform float u_thickness = 0.01;
uniform float u_stride = 0.5; // Lower means better quality, but more steps along the ray, aka worse performance

uniform float u_ssrIntensity = 0.125;
uniform float u_edgeFade = 0.01; // Larger values mean more aggressive fade out
uniform int u_debugMode = 0;

float Hash12(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

bool IsSky(vec3 n) {
    return (n.x == 0.0 && n.y == 0.0 && n.z == 0.0);
}

vec3 FresnelSchlick2(float cosTheta, vec3 F0) {
    float f = pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
    return F0 + (1.0 - F0) * f;
}

float EdgeFade(vec2 uv) {
    float edge = min(min(uv.x, 1.0 - uv.x), min(uv.y, 1.0 - uv.y));
    return clamp(edge / max(u_edgeFade, 0.0001), 0.0, 1.0);
}

// Viewport-local UV (0..1) -> atlas/global UV (0..1)
vec2 ViewportUVToGlobalUV(vec2 viewportUV, ViewportData v) {
    return vec2(v.posX, v.posY) + viewportUV * vec2(v.sizeX, v.sizeY);
}

// Atlas/global UV -> texelFetch
float FetchViewZ_GlobalUV(vec2 globalUV, ivec2 viewZSize) {
    ivec2 p = ivec2(globalUV * vec2(viewZSize));
    return texelFetch(ViewSpaceDepthTexture, p, 0).r;
}

// viewport-local UV (0..1) from atlas pixel coords
vec2 GlobalPixelToViewportUV(ivec2 px, ViewportData v) {
    ivec2 localPx = px - ivec2(v.xOffset, v.yOffset);
    return (vec2(localPx) + 0.5) / vec2(float(v.width), float(v.height));
}

// Refine an intersection between [tA, tB] where dz(tA) <= 0 and dz(tB) > 0.
// Returns true if we get a refined hit that passes the thickness gate.
bool BinaryRefineHit(
    vec3 P_view,
    vec3 R_view,
    mat4 projectionMatrix,
    ViewportData v,
    ivec2 viewZSize,
    float thickness,
    inout float tA,
    inout float tB,
    out vec2 outViewportUV,
    out float outT)
{
    float a = tA;
    float b = tB;

    vec2 uv = vec2(0.0);
    float bestT = b;

    for (int j = 0; j < 6; ++j) {
        float m = 0.5 * (a + b);

        vec3 midP_view = P_view + R_view * m;
        vec4 midClip = projectionMatrix * vec4(midP_view, 1.0);
        if (midClip.w <= 0.000001) {
            b = m;
            continue;
        }

        float invW = 1.0 / midClip.w;
        vec2 midViewportUV = midClip.xy * invW * 0.5 + 0.5;
        if (any(lessThan(midViewportUV, vec2(0.0))) || any(greaterThan(midViewportUV, vec2(1.0)))) {
            b = m;
            continue;
        }

        vec2 midGlobalUV = ViewportUVToGlobalUV(midViewportUV, v);

        float midSceneP_view = FetchViewZ_GlobalUV(midGlobalUV, viewZSize);
        float midDz = midSceneP_view - midP_view.z;

        if (midDz > 0.0) {
            b = m;
            uv = midViewportUV;
            bestT = m;
        } else {
            a = m;
        }
    }

    vec3 refineP_view = P_view + R_view * bestT;
    vec4 refineClip = projectionMatrix * vec4(refineP_view, 1.0);
    if (refineClip.w <= 0.000001) return false;

    float invW = 1.0 / refineClip.w;
    vec2 refineViewportUV = refineClip.xy * invW * 0.5 + 0.5;
    if (any(lessThan(refineViewportUV, vec2(0.0))) || any(greaterThan(refineViewportUV, vec2(1.0)))) return false;

    vec2 refineGlobalUV = ViewportUVToGlobalUV(refineViewportUV, v);

    float refineSceneP_view = FetchViewZ_GlobalUV(refineGlobalUV, viewZSize);

    float refineDz = refineSceneP_view - refineP_view.z;

    if (refineDz > 0.0 && refineDz < thickness) {
        outViewportUV = refineViewportUV;
        outT = bestT;
        return true;
    }

    return false;
}

void main() {
    //return; // REMOVE ME!

    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 outputSize = imageSize(LightingImage);

    if (pixelCoords.x >= outputSize.x || pixelCoords.y >= outputSize.y) {
        return;
    }

    uint viewportIndex = ComputeViewportIndexFromSplitscreenMode(pixelCoords, outputSize, rendererData.splitscreenMode);
    ViewportData v = viewportData[viewportIndex];

    vec2 uv = (vec2(pixelCoords) + 0.5) / vec2(outputSize);

    vec3 normalRaw = texelFetch(NormalTexture, pixelCoords, 0).xyz;
    if (IsSky(normalRaw)) {
        return;
    }

    vec3 N_world = normalize(normalRaw);

    vec4 rma = texelFetch(RMATexture, pixelCoords, 0);
    float roughness = rma.r;
    float metallic  = rma.g;
    float gloss = 1 - roughness;

    // Early out for areas with basically no SSR
    if (gloss < 0.15) return;

    mat4 viewMatrix = v.view;
    mat4 projectionMatrix = v.projection;
    mat4 inverseView = v.inverseView;

    vec3 viewPosWorld = inverseView[3].xyz;
    vec3 worldPos = texelFetch(WorldPositionTexture, pixelCoords, 0).rgb;

    ivec2 viewZSize = textureSize(ViewSpaceDepthTexture, 0);
    float viewspaceDepth = texelFetch(ViewSpaceDepthTexture, pixelCoords, 0).r;

    vec3 V_world = normalize(viewPosWorld - worldPos);
    vec3 R_world = normalize(reflect(-V_world, N_world));

    vec3 baseColor = texelFetch(BaseColorTexture, pixelCoords, 0).rgb;
    vec3 gammaBaseColor = pow(baseColor, vec3(2.2));
    vec3 F0 = mix(vec3(0.04), gammaBaseColor, metallic);

    float NoV = clamp(dot(N_world, V_world), 0.0, 1.0);
    vec3 F = FresnelSchlick2(NoV, F0);

    // Fresnel gate early out
    float Fstrength = max(max(F.r, F.g), F.b);
    if (Fstrength < 0.02) return;

    vec3 P_view = (viewMatrix * vec4(worldPos, 1.0)).xyz;
    vec3 R_view = normalize((viewMatrix * vec4(R_world, 0.0)).xyz);

    float jitter = Hash12(vec2(pixelCoords)) - 0.5;
    float rayT = u_stride * (0.5 + jitter);

    float hit = 0.0;
    vec2 hitViewportUV = vec2(0.0);
    vec2 hitGlobalUV = vec2(0.0);
    float hitRayT = 0.0;
    vec3 hitColor = vec3(0.0);

    float maxT = u_maxRayDistance;

    float rayTPrev = rayT;
    float dzPrev = 0.0;
    bool hasPrev = false;

    //float steps = mix(u_minSteps, u_maxSteps, gloss * gloss);
    int steps = int(mix(float(u_minSteps), float(u_maxSteps), gloss * gloss));

    for (int i = 0; i < steps; ++i) {
        if (rayT > maxT) break;

        vec3 sampleP_view = P_view + R_view * rayT;

        vec4 clip = projectionMatrix * vec4(sampleP_view, 1.0);
        if (clip.w <= 0.000001) break;

        float invW = 1.0 / clip.w;
        vec2 sampleViewportUV = clip.xy * invW * 0.5 + 0.5;

        // bounds check in viewport-local space
        if (any(lessThan(sampleViewportUV, vec2(0.0))) || any(greaterThan(sampleViewportUV, vec2(1.0)))) {
            break;
        }

        // sample gbuffer in atlas/global space
        vec2 sampleGlobalUV = ViewportUVToGlobalUV(sampleViewportUV, v);

        float sceneP_view = FetchViewZ_GlobalUV(sampleGlobalUV, viewZSize);

        float thickness = u_thickness + rayT * 0.002;
        float dz = sceneP_view - sampleP_view.z;

        if (dz > 0.0 && dz < thickness) {
            hit = 1.0;
            hitViewportUV = sampleViewportUV;
            hitGlobalUV = sampleGlobalUV;
            hitRayT = rayT;
            break;
        }

        // Crossing detect + binary refine
        if (hasPrev) {
            bool crossed = (dzPrev <= 0.0 && dz > 0.0);
            if (crossed) {
                vec2 refineViewportUV;
                float refineT;

                float tA = rayTPrev;
                float tB = rayT;

                if (BinaryRefineHit(P_view, R_view, projectionMatrix, v, viewZSize, thickness, tA, tB, refineViewportUV, refineT)) {
                    hit = 1.0;
                    hitViewportUV = refineViewportUV;
                    hitGlobalUV = ViewportUVToGlobalUV(refineViewportUV, v);
                    hitRayT = refineT;
                    break;
                }
            }
        }

        hasPrev = true;
        rayTPrev = rayT;
        dzPrev = dz;

        float stepBase = u_stride * mix(1.0, 2.0, roughness);
        float stepSlope = stepBase * 0.05; // was 0.03 * u_stride
        rayT += stepBase + rayT * stepSlope;
    }

    if (hit > 0.5) {
        float maxMip = float(textureQueryLevels(DownsizedLightingTexture) - 1);
        //float lod = clamp(roughness * roughness * maxMip, 0.0, maxMip);
        //float lod = clamp(sqrt(roughness) * maxMip, 0.0, maxMip);
        float lod = clamp(pow(roughness, 0.75) * maxMip, 0.0, maxMip);

        // IMPORTANT: sample lighting in atlas/global UV space
        hitColor = textureLod(DownsizedLightingTexture, hitGlobalUV, lod).rgb;
    }

    vec4 base = imageLoad(LightingImage, pixelCoords);

    float edgeW = (hit > 0.5) ? EdgeFade(hitViewportUV) : 0.0;

    if (u_debugMode == 1) {
        imageStore(LightingImage, pixelCoords, vec4(vec3(hit), 1.0));
        return;
    }
    if (u_debugMode == 2) {
        imageStore(LightingImage, pixelCoords, vec4(hitColor, 1.0));
        return;
    }

    float roughW = clamp((1.0 - roughness) * 2.5, 0.0, 1.0);
    //roughW = gloss * gloss;  // smoother falloff
    roughW = roughW * roughW;

    float weight = hit * u_ssrIntensity * edgeW * roughW;

    // (fast, but can overbright)
    vec3 reflection = hitColor * weight * F;
    vec3 composed = base.rgb + reflection;

    imageStore(LightingImage, pixelCoords, vec4(composed, base.a));
    //imageStore(LightingImage, pixelCoords, vec4(reflection, base.a));
}

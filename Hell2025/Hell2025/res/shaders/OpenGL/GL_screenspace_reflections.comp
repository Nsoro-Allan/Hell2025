#version 460

#include "../common/lighting.glsl"
#include "../common/post_processing.glsl"
#include "../common/types.glsl"
#include "../common/util.glsl"

layout(local_size_x = TILE_SIZE, local_size_y = TILE_SIZE, local_size_z = 1) in;

layout(rgba16f, binding = 0) uniform image2D LightingImage;

layout (binding = 1) uniform sampler2D BaseColorTexture;
layout (binding = 2) uniform sampler2D NormalTexture;
layout (binding = 3) uniform sampler2D RMATexture;
layout (binding = 4) uniform sampler2D DepthTexture;
layout (binding = 5) uniform sampler2D WorldPositionTexture;
layout (binding = 6) uniform usampler2D ViewportIndexTexture;
layout (binding = 7) uniform sampler2D DownsizedLightingTexture;

readonly restrict layout(std430, binding = 2) buffer viewportDataBuffer {
    ViewportData viewportData[];
};

uniform float u_maxRayDistance = 25.0;
uniform int u_maxSteps = 64;
uniform float u_thickness = 0.12;
uniform float u_stride = 0.25;

// Overall SSR intensity scalar (easy tuning knob)
uniform float u_ssrIntensity = 0.35;

// Edge fade distance in UV space
uniform float u_edgeFade = 0.08;

// Debug: 0 = normal composite, 1 = hit mask, 2 = hit color only
uniform int u_debugMode = 0;

float Hash12(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

bool IsSky(vec3 n) {
    return (n.x == 0.0 && n.y == 0.0 && n.z == 0.0);
}

vec3 FresnelSchlick2(float cosTheta, vec3 F0) {
    float f = pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
    return F0 + (1.0 - F0) * f;
}

vec3 ReconstructViewPosFromDepth(vec2 uv, float depth01, mat4 inverseProjection) {
    float zNdc = depth01 * 2.0 - 1.0;
    vec4 clip = vec4(uv * 2.0 - 1.0, zNdc, 1.0);
    vec4 viewH = inverseProjection * clip;
    return viewH.xyz / max(viewH.w, 0.000001);
}

float RoughnessWeight(float roughness) {
    // Stronger falloff so SSR mostly lives on glossy materials
    float w = clamp(1.0 - roughness, 0.0, 1.0);
    return w * w;
}

float EdgeFade(vec2 uv) {
    float edge = min(min(uv.x, 1.0 - uv.x), min(uv.y, 1.0 - uv.y));
    return clamp(edge / max(u_edgeFade, 0.0001), 0.0, 1.0);
}

void main() {
    return;

    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 outputSize = imageSize(LightingImage);

    if (pixelCoords.x >= outputSize.x || pixelCoords.y >= outputSize.y) {
        return;
    }

    vec2 uv = (vec2(pixelCoords) + 0.5) / vec2(outputSize);

    vec3 normalRaw = texture(NormalTexture, uv).xyz;
    if (IsSky(normalRaw)) {
        return;
    }

    vec3 N_world = normalize(normalRaw);

    vec4 rma = texture(RMATexture, uv);
    float roughness = rma.r;
    float metallic  = rma.g;

    uint viewportIndex = texture(ViewportIndexTexture, uv).r;

    mat4 viewMatrix = viewportData[viewportIndex].view;
    mat4 projectionMatrix = viewportData[viewportIndex].projection;
    mat4 inverseProjection = viewportData[viewportIndex].inverseProjection;
    mat4 inverseView = viewportData[viewportIndex].inverseView;

    vec3 viewPosWorld = inverseView[3].xyz;
    vec3 worldPos = texture(WorldPositionTexture, uv).rgb;

    vec3 V_world = normalize(viewPosWorld - worldPos);
    vec3 R_world = normalize(reflect(-V_world, N_world));

    vec3 P_view = (viewMatrix * vec4(worldPos, 1.0)).xyz;
    vec3 R_view = normalize((viewMatrix * vec4(R_world, 0.0)).xyz);

    float facing = clamp(dot(normalize(-P_view), R_view), 0.0, 1.0);

    float jitter = Hash12(vec2(pixelCoords)) - 0.5;
    float rayT = u_stride * (0.5 + jitter);

    float hit = 0.0;
    vec2 hitUV = vec2(0.0);
    float hitRayT = 0.0;
    vec3 hitColor = vec3(0.0);

    float maxT = u_maxRayDistance;

    for (int i = 0; i < u_maxSteps; ++i) {
        if (rayT > maxT) break;

        vec3 sampleP_view = P_view + R_view * rayT;

        vec4 clip = projectionMatrix * vec4(sampleP_view, 1.0);
        if (clip.w <= 0.000001) break;

        vec3 ndc = clip.xyz / clip.w;
        vec2 sampleUV = ndc.xy * 0.5 + 0.5;

        if (sampleUV.x < 0.0 || sampleUV.x > 1.0 || sampleUV.y < 0.0 || sampleUV.y > 1.0) {
            break;
        }

        float sceneDepth01 = texture(DepthTexture, sampleUV).r;
        vec3 sceneP_view = ReconstructViewPosFromDepth(sampleUV, sceneDepth01, inverseProjection);

        float thickness = u_thickness + rayT * 0.002;

        float dz = sceneP_view.z - sampleP_view.z;

        if (dz > 0.0 && dz < thickness) {
            hit = 1.0;
            hitUV = sampleUV;
            hitRayT = rayT;
            hitColor = texture(DownsizedLightingTexture, sampleUV).rgb;
            break;
        }

        rayT += u_stride * (1.0 + rayT * 0.03);
    }

    // Optional cheap denoise for rough surfaces: 5-tap cross blur on hitColor
    // Uses DownsizedLightingTexture as the source (since that's what you reflect).
    if (hit > 0.5) {
        float blurRadiusPixels = mix(0.0, 2.0, clamp(roughness, 0.0, 1.0));
        if (blurRadiusPixels > 0.01) {
            vec2 texel = 1.0 / vec2(textureSize(DownsizedLightingTexture, 0));
            vec2 o = texel * blurRadiusPixels;

            vec3 sum = hitColor;
            sum += texture(DownsizedLightingTexture, hitUV + vec2( o.x, 0.0)).rgb;
            sum += texture(DownsizedLightingTexture, hitUV + vec2(-o.x, 0.0)).rgb;
            sum += texture(DownsizedLightingTexture, hitUV + vec2(0.0,  o.y)).rgb;
            sum += texture(DownsizedLightingTexture, hitUV + vec2(0.0, -o.y)).rgb;

            hitColor = sum * 0.2;
        }
    }

    // Base (current lighting)
    vec4 base = imageLoad(LightingImage, pixelCoords);

    // Fresnel and roughness weighting
    vec3 baseColor = texture(BaseColorTexture, uv).rgb;
    vec3 gammaBaseColor = pow(baseColor, vec3(2.2));
    vec3 F0 = mix(vec3(0.04), gammaBaseColor, metallic);

    float NoV = clamp(dot(N_world, V_world), 0.0, 1.0);
    vec3 F = FresnelSchlick(NoV, F0);

    float edgeW = EdgeFade(hitUV);
    
    // Debug modes
    if (u_debugMode == 1) {
        imageStore(LightingImage, pixelCoords, vec4(vec3(hit), 1.0));
        return;
    }
    if (u_debugMode == 2) {
        imageStore(LightingImage, pixelCoords, vec4(hitColor, 1.0));
        return;
    }
 
    // allow SSR to survive even on rough surfaces
    float roughW = clamp((1.0 - roughness) * 2.5, 0.0, 1.0);
    float weight = hit * 0.25 * roughW;

    vec3 composed = base.rgb + hitColor * weight;

    imageStore(LightingImage, pixelCoords, vec4(composed, base.a));
}

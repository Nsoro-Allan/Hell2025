#version 460

#include "../common/lighting.glsl"
#include "../common/post_processing.glsl"
#include "../common/types.glsl"
#include "../common/util.glsl"

layout(local_size_x = TILE_SIZE, local_size_y = TILE_SIZE, local_size_z = 1) in;

layout(rgba16f, binding = 0) uniform image2D LightingImage;

layout (binding = 1) uniform sampler2D BaseColorTexture;
layout (binding = 2) uniform sampler2D NormalTexture;
layout (binding = 3) uniform sampler2D RMATexture;
layout (binding = 4) uniform sampler2D DepthTexture;
layout (binding = 5) uniform sampler2D WorldPositionTexture;
layout (binding = 6) uniform usampler2D ViewportIndexTexture;
layout (binding = 7) uniform sampler2D DownsizedLightingTexture;

readonly restrict layout(std430, binding = 2) buffer viewportDataBuffer {
    ViewportData viewportData[];
};

uniform float u_maxRayDistance = 10.0;
uniform int u_maxSteps = 32;
uniform float u_thickness = 0.05;
uniform float u_stride = 0.125; // Lower means better quality, but more steps along the ray, aka worse performance

uniform float u_ssrIntensity = 0.5;
uniform float u_edgeFade = 0.1; // Larger values mean more aggressive fade out
uniform int u_debugMode = 0;

float Hash12(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

bool IsSky(vec3 n) {
    return (n.x == 0.0 && n.y == 0.0 && n.z == 0.0);
}

vec3 ReconstructViewPosFromDepth(vec2 uv, float depth01, mat4 inverseProjection) {
    float zNdc = depth01 * 2.0 - 1.0;
    vec4 clip = vec4(uv * 2.0 - 1.0, zNdc, 1.0);
    vec4 viewH = inverseProjection * clip;
    return viewH.xyz / max(viewH.w, 0.000001);
}

vec3 FresnelSchlick2(float cosTheta, vec3 F0) {
    float f = pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
    return F0 + (1.0 - F0) * f;
}

float EdgeFade(vec2 uv) {
    float edge = min(min(uv.x, 1.0 - uv.x), min(uv.y, 1.0 - uv.y));
    return clamp(edge / max(u_edgeFade, 0.0001), 0.0, 1.0);
}

// Refine an intersection between [tA, tB] where dz(tA) <= 0 and dz(tB) > 0.
// Returns true if we get a refined hit that passes the thickness gate.
bool BinaryRefineHit(
    vec3 P_view,
    vec3 R_view,
    mat4 projectionMatrix,
    mat4 inverseProjection,
    float thickness,
    inout float tA,
    inout float tB,
    out vec2 outUV,
    out float outT)
{
    float a = tA;
    float b = tB;

    vec2 uv = vec2(0.0);
    float bestT = b;

    for (int j = 0; j < 6; ++j) {
        float m = 0.5 * (a + b);

        vec3 midP_view = P_view + R_view * m;
        vec4 midClip = projectionMatrix * vec4(midP_view, 1.0);
        if (midClip.w <= 0.000001) {
            b = m;
            continue;
        }

        vec2 midUV = (midClip.xy / midClip.w) * 0.5 + 0.5;
        if (any(lessThan(midUV, vec2(0.0))) || any(greaterThan(midUV, vec2(1.0)))) {
            b = m;
            continue;
        }

        float midDepth01 = texture(DepthTexture, midUV).r;
        vec3 midSceneP_view = ReconstructViewPosFromDepth(midUV, midDepth01, inverseProjection);

        float midDz = midSceneP_view.z - midP_view.z;

        if (midDz > 0.0) {
            b = m;
            uv = midUV;
            bestT = m;
        } else {
            a = m;
        }
    }

    vec3 refineP_view = P_view + R_view * bestT;
    vec4 refineClip = projectionMatrix * vec4(refineP_view, 1.0);
    if (refineClip.w <= 0.000001) return false;

    vec2 refineUV = (refineClip.xy / refineClip.w) * 0.5 + 0.5;
    if (any(lessThan(refineUV, vec2(0.0))) || any(greaterThan(refineUV, vec2(1.0)))) return false;

    float refineDepth01 = texture(DepthTexture, refineUV).r;
    vec3 refineSceneP_view = ReconstructViewPosFromDepth(refineUV, refineDepth01, inverseProjection);

    float refineDz = refineSceneP_view.z - refineP_view.z;

    if (refineDz > 0.0 && refineDz < thickness) {
        outUV = refineUV;
        outT = bestT;
        return true;
    }

    return false;
}

void main() {
    //return;
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 outputSize = imageSize(LightingImage);

    if (pixelCoords.x >= outputSize.x || pixelCoords.y >= outputSize.y) {
        return;
    }

    vec2 uv = (vec2(pixelCoords) + 0.5) / vec2(outputSize);

    vec3 normalRaw = texture(NormalTexture, uv).xyz;
    if (IsSky(normalRaw)) {
        return;
    }

    vec3 N_world = normalize(normalRaw);

    vec4 rma = texture(RMATexture, uv);
    float roughness = rma.r;
    float metallic  = rma.g;

    uint viewportIndex = texture(ViewportIndexTexture, uv).r;

    mat4 viewMatrix = viewportData[viewportIndex].view;
    mat4 projectionMatrix = viewportData[viewportIndex].projection;
    mat4 inverseProjection = viewportData[viewportIndex].inverseProjection;
    mat4 inverseView = viewportData[viewportIndex].inverseView;

    vec3 viewPosWorld = inverseView[3].xyz;
    vec3 worldPos = texture(WorldPositionTexture, uv).rgb;

    vec3 V_world = normalize(viewPosWorld - worldPos);
    vec3 R_world = normalize(reflect(-V_world, N_world));

    vec3 P_view = (viewMatrix * vec4(worldPos, 1.0)).xyz;
    vec3 R_view = normalize((viewMatrix * vec4(R_world, 0.0)).xyz);

    float jitter = Hash12(vec2(pixelCoords)) - 0.5;
    float rayT = u_stride * (0.5 + jitter);

    float hit = 0.0;
    vec2 hitUV = vec2(0.0);
    float hitRayT = 0.0;
    vec3 hitColor = vec3(0.0);

    float maxT = u_maxRayDistance;

    float rayTPrev = rayT;
    float dzPrev = 0.0;
    bool hasPrev = false;

    for (int i = 0; i < u_maxSteps; ++i) {
        if (rayT > maxT) break;

        vec3 sampleP_view = P_view + R_view * rayT;

        vec4 clip = projectionMatrix * vec4(sampleP_view, 1.0);
        if (clip.w <= 0.000001) break;

        vec3 ndc = clip.xyz / clip.w;
        vec2 sampleUV = ndc.xy * 0.5 + 0.5;

        if (any(lessThan(sampleUV, vec2(0.0))) || any(greaterThan(sampleUV, vec2(1.0)))) {
            break;
        }

        float sceneDepth01 = texture(DepthTexture, sampleUV).r;
        vec3 sceneP_view = ReconstructViewPosFromDepth(sampleUV, sceneDepth01, inverseProjection);

        float thickness = u_thickness + rayT * 0.002;
        float dz = sceneP_view.z - sampleP_view.z;

        // Direct accept if we land inside the thickness window
        if (dz > 0.0 && dz < thickness) {
            hit = 1.0;
            hitUV = sampleUV;
            hitRayT = rayT;
            break;
        }

        // Crossing detect + binary refine
        if (hasPrev) {
            bool crossed = (dzPrev <= 0.0 && dz > 0.0);
            if (crossed) {
                vec2 refineUV;
                float refineT;

                float tA = rayTPrev;
                float tB = rayT;

                if (BinaryRefineHit(P_view, R_view, projectionMatrix, inverseProjection, thickness, tA, tB, refineUV, refineT)) {
                    hit = 1.0;
                    hitUV = refineUV;
                    hitRayT = refineT;
                    break;
                }
            }
        }

        hasPrev = true;
        rayTPrev = rayT;
        dzPrev = dz;

        rayT += u_stride * (1.0 + rayT * 0.03);
    }

    if (hit > 0.5) {
        hitColor = texture(DownsizedLightingTexture, hitUV).rgb;

        float blurRadiusPixels = mix(0.0, 2.0, clamp(roughness, 0.0, 1.0));
        if (blurRadiusPixels > 0.01) {
            vec2 texel = 1.0 / vec2(textureSize(DownsizedLightingTexture, 0));
            vec2 o = texel * blurRadiusPixels;

            vec3 sum = hitColor;
            sum += texture(DownsizedLightingTexture, hitUV + vec2( o.x, 0.0)).rgb;
            sum += texture(DownsizedLightingTexture, hitUV + vec2(-o.x, 0.0)).rgb;
            sum += texture(DownsizedLightingTexture, hitUV + vec2(0.0,  o.y)).rgb;
            sum += texture(DownsizedLightingTexture, hitUV + vec2(0.0, -o.y)).rgb;

            hitColor = sum * 0.2;
        }
    }

    vec4 base = imageLoad(LightingImage, pixelCoords);

    vec3 baseColor = texture(BaseColorTexture, uv).rgb;
    vec3 gammaBaseColor = pow(baseColor, vec3(2.2));
    vec3 F0 = mix(vec3(0.04), gammaBaseColor, metallic);

    float NoV = clamp(dot(N_world, V_world), 0.0, 1.0);
    vec3 F = FresnelSchlick2(NoV, F0);

    float edgeW = (hit > 0.5) ? EdgeFade(hitUV) : 0.0;

    if (u_debugMode == 1) {
        imageStore(LightingImage, pixelCoords, vec4(vec3(hit), 1.0));
        return;
    }
    if (u_debugMode == 2) {
        imageStore(LightingImage, pixelCoords, vec4(hitColor, 1.0));
        return;
    }

    float roughW = clamp((1.0 - roughness) * 2.5, 0.0, 1.0);
    roughW = roughW * roughW;

    //
    //weight = 1.0;

    //float roughW = 1.0 - roughness;
    //roughW = roughW * roughW;
    //

    float gloss = 1.0 - roughness;
    roughW = gloss * gloss;  // smoother falloff

    float weight = hit * u_ssrIntensity * edgeW * roughW;

    // Keep your existing additive composite (fast, but can overbright)
    vec3 reflection = hitColor * weight * F;
    vec3 composed = base.rgb + reflection;

    
    imageStore(LightingImage, pixelCoords, vec4(composed, base.a));
    //imageStore(LightingImage, pixelCoords, vec4(reflection, base.a));
}

#version 460

#include "../common/lighting.glsl"
#include "../common/post_processing.glsl"
#include "../common/types.glsl"
#include "../common/util.glsl"

layout(local_size_x = TILE_SIZE, local_size_y = TILE_SIZE, local_size_z = 1) in;

layout(rgba16f, binding = 0) writeonly uniform image2D SSRCurrentImage;

layout (binding = 1) uniform sampler2D NormalTexture;
layout (binding = 2) uniform sampler2D RMATexture;
layout (binding = 3) uniform sampler2D DepthTexture;
layout (binding = 4) uniform sampler2D WorldPositionTexture;
layout (binding = 5) uniform usampler2D ViewportIndexTexture;
layout (binding = 6) uniform sampler2D DownsizedLightingTexture;

readonly restrict layout(std430, binding = 2) buffer viewportDataBuffer {
    ViewportData viewportData[];
};

uniform float u_maxRayDistance = 25.0;
uniform int u_maxSteps = 64;
uniform float u_thickness = 0.12;
uniform float u_stride = 0.25;

float Hash12(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

bool IsSky(vec3 n) {
    return (n.x == 0.0 && n.y == 0.0 && n.z == 0.0);
}

vec3 ReconstructViewPosFromDepth(vec2 uv, float depth01, mat4 inverseProjection) {
    float zNdc = depth01 * 2.0 - 1.0;
    vec4 clip = vec4(uv * 2.0 - 1.0, zNdc, 1.0);
    vec4 viewH = inverseProjection * clip;
    return viewH.xyz / max(viewH.w, 0.000001);
}

void main() {
    ivec2 halfPixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 halfSize = imageSize(SSRCurrentImage);

    if (halfPixelCoords.x >= halfSize.x || halfPixelCoords.y >= halfSize.y) {
        return;
    }

    vec2 uv = (vec2(halfPixelCoords) + 0.5) / vec2(halfSize);

    vec3 normalRaw = texture(NormalTexture, uv).xyz;
    if (IsSky(normalRaw)) {
        imageStore(SSRCurrentImage, halfPixelCoords, vec4(0.0));
        return;
    }

    vec3 N_world = normalize(normalRaw);

    vec4 rma = texture(RMATexture, uv);
    float roughness = rma.r;

    uint viewportIndex = texture(ViewportIndexTexture, uv).r;

    mat4 viewMatrix = viewportData[viewportIndex].view;
    mat4 projectionMatrix = viewportData[viewportIndex].projection;
    mat4 inverseProjection = viewportData[viewportIndex].inverseProjection;
    mat4 inverseView = viewportData[viewportIndex].inverseView;

    vec3 viewPosWorld = inverseView[3].xyz;
    vec3 worldPos = texture(WorldPositionTexture, uv).rgb;

    vec3 V_world = normalize(viewPosWorld - worldPos);
    vec3 R_world = normalize(reflect(-V_world, N_world));

    vec3 P_view = (viewMatrix * vec4(worldPos, 1.0)).xyz;
    vec3 R_view = normalize((viewMatrix * vec4(R_world, 0.0)).xyz);

    float jitter = Hash12(vec2(halfPixelCoords)) - 0.5;
    float rayT = u_stride * (0.5 + jitter);

    float hit = 0.0;
    vec3 hitColor = vec3(0.0);

    float maxT = u_maxRayDistance;

    for (int i = 0; i < u_maxSteps; ++i) {
        if (rayT > maxT) break;

        vec3 sampleP_view = P_view + R_view * rayT;

        vec4 clip = projectionMatrix * vec4(sampleP_view, 1.0);
        if (clip.w <= 0.000001) break;

        vec3 ndc = clip.xyz / clip.w;
        vec2 sampleUV = ndc.xy * 0.5 + 0.5;

        if (sampleUV.x < 0.0 || sampleUV.x > 1.0 || sampleUV.y < 0.0 || sampleUV.y > 1.0) {
            break;
        }

        float sceneDepth01 = texture(DepthTexture, sampleUV).r;
        vec3 sceneP_view = ReconstructViewPosFromDepth(sampleUV, sceneDepth01, inverseProjection);

        float thickness = u_thickness + rayT * 0.002;
        float dz = sceneP_view.z - sampleP_view.z;

        if (dz > 0.0 && dz < thickness) {
            hit = 1.0;
            hitColor = texture(DownsizedLightingTexture, sampleUV).rgb;
            break;
        }

        rayT += u_stride;
    }

    float roughW = clamp((1.0 - roughness) * 2.5, 0.0, 1.0);
    float weight = hit * 0.25 * roughW;

    imageStore(SSRCurrentImage, halfPixelCoords, vec4(hitColor, weight));
}

#version 460
#include "../common/lighting.glsl"
#include "../common/types.glsl"
#include "../common/util.glsl"

layout(local_size_x = 16, local_size_y = 16) in;

layout (binding = 1) uniform sampler2D uDepth;
layout (binding = 2) uniform sampler3D uNoiseVol;
layout (binding = 3) uniform sampler2D ViewSpaceDepthTexture;
layout (binding = 4) uniform sampler2D WorldPositionTexture;
layout (binding = 4, rgba16f) uniform image2D OutputFogImage;

readonly restrict layout(std430, binding = 1) buffer rendererDataBuffer { RendererData rendererData; };
readonly restrict layout(std430, binding = 2) buffer viewportDataBuffer { ViewportData viewportData[]; };

uniform int u_noiseSeed;

uniform float u_time;

const vec3 fogSpeed = vec3(0.10, 0.02, 0.10);
float u_finalDampingFactor = 0.02;

const float MAX_FOG_DIST = 30.0;
const int NUM_STEPS = 48;

const float nearFadeAmbient = 1.0;
const float farFadeAmbient = 5;

const float nearFadeFlashlight = 0.025;
const float farFadeFlashlight = 5;

const float noiseScaleXZ = 1.0 / 8.0 * 0.75;// * 0.75; // repeat every x metres and x == (1 / y)
const float noiseScaleY = 1.0 / 6.0 * 0.75;// * 0.75; // repeat every x metres and x == (1 / y)

float dt = MAX_FOG_DIST / float(NUM_STEPS);

//float u_densityBias = 0.05;
//float u_densityScale = 1.5;

float u_densityBias = 0.005;
float u_densityScale = 1.250;

// Mip selection tweakables
uniform float u_noiseMipBias = 0.0;        // start neutral
uniform float u_noiseMipScale = 1.0;       // start neutral
uniform float u_noiseMinMip = 0.0;         // allow full detail up close
uniform float u_noiseMaxMip = 2.0;         // do not go too blurry voxel grid in high mips appears

// Distance mip ramp tweakables (sharp near, blur far)
uniform float u_noiseMipNear = 0.0;        // sharp near camera
uniform float u_noiseMipFar = 2.0;         // blur at distance (try 2.5..4.0)
uniform float u_noiseMipNearDist = 1.175;   // metres (push noise away from the camera a bit)
uniform float u_noiseMipFarDist = 5.0;    // metres (where it reaches far mip)
uniform float u_noiseMipCurve = 5.6;       // pushes the blur transition farther out (less mush close)

// fog speeds
const float timeScrollSpeed = 4 * 1.1;
const float xMorphSpeed = 5.0 * 1.1;
const float zMorphSpeed = 5.0 * 1.1;
const float yScrollSpeed = 2 * 1.1;

// How much to respect dt-driven mip (helps avoid aliasing if dt is large)
uniform float u_noiseMipRespectDt;      // 0 = ignore dt mip, 1 = force at least dt mip

uniform float u_noiseScaleNearMult = 1.0;
uniform float u_noiseScaleFarMult = 1.0;
uniform float u_noiseScaleStartDist = 6.0;
uniform float u_noiseScaleEndDist = 22.0;
uniform float u_noiseScaleCurve = 2.0;

// Random sampling functions
uint seed = 0u;

void hash(){
    seed ^= 2747636419u;
    seed *= 2654435769u;
    seed ^= seed >> 16;
    seed *= 2654435769u;
    seed ^= seed >> 16;
    seed *= 2654435769u;
}

float random(){
    hash();
    return float(seed)/4294967295.0;
}

ivec2 ViewportUVToAtlasPixel(vec2 viewportUV, ViewportData v) {
    ivec2 localPx = ivec2(viewportUV * vec2(float(v.width), float(v.height)));
    return ivec2(v.xOffset, v.yOffset) + localPx;
}

// World position reconstruction from depth (ZERO_TO_ONE)
vec3 ReconstructWorldPosFromViewportUVDepth(vec2 viewportUV, float depth, mat4 inverseProjectionView) {
    vec4 clip = vec4(viewportUV * 2.0 - 1.0, depth, 1.0);
    vec4 worldH = inverseProjectionView * clip;
    return worldH.xyz / max(worldH.w, 1e-6);
}

vec3 ReconstructWorldPosFromDepth01_ZeroToOne(
    vec2 viewportUV,
    float depth01,
    mat4 inverseProjection,
    mat4 inverseView)
{
    vec2 ndcXY = viewportUV * 2.0 - 1.0;
    float ndcZ = depth01; // already 0..1

    vec4 viewH = inverseProjection * vec4(ndcXY, ndcZ, 1.0);
    vec3 viewPos = viewH.xyz / max(viewH.w, 1e-6);

    vec4 worldH = inverseView * vec4(viewPos, 1.0);
    return worldH.xyz;
}

// Compute a mip level that matches the current step length dt to the world-space texel size of mip 0.
// This helps prevent undersampling when NUM_STEPS is low.
float ComputeNoiseMipFromDt(float stepLengthWorld, int baseDim, float periodXZ, float periodY) {
    float worldTexelXZ = periodXZ / float(baseDim);
    float worldTexelY  = periodY  / float(baseDim);
    float worldTexel   = max(worldTexelXZ, worldTexelY);

    float lod = log2(max(stepLengthWorld / max(worldTexel, 1e-6), 1e-6));
    lod = lod * u_noiseMipScale + u_noiseMipBias;

    float maxLevel = float(textureQueryLevels(uNoiseVol) - 1);
    lod = clamp(lod, max(u_noiseMinMip, 0.0), min(u_noiseMaxMip, maxLevel));
    return lod;
}

float ComputeNoiseMipFromDistance(float t) {
    float k = clamp((t - u_noiseMipNearDist) / max(u_noiseMipFarDist - u_noiseMipNearDist, 1e-6), 0.0, 1.0);
    k = pow(k, max(u_noiseMipCurve, 1e-6));
    float lod = mix(u_noiseMipNear, u_noiseMipFar, k);

    float maxLevel = float(textureQueryLevels(uNoiseVol) - 1);
    lod = lod * u_noiseMipScale + u_noiseMipBias;
    lod = clamp(lod, max(u_noiseMinMip, 0.0), min(u_noiseMaxMip, maxLevel));
    return lod;
}

float ComputeNoiseScaleMultiplier(float t) {
    float k = clamp((t - u_noiseScaleStartDist) / max(u_noiseScaleEndDist - u_noiseScaleStartDist, 1e-6), 0.0, 1.0);
    k = pow(k, max(u_noiseScaleCurve, 1e-6));
    return mix(u_noiseScaleNearMult, u_noiseScaleFarMult, k);
}

void main2() {
    ivec2 px = ivec2(gl_GlobalInvocationID.xy);
    ivec2 resolution = imageSize(OutputFogImage);
    if (px.x >= resolution.x || px.y >= resolution.y) return;

    uint viewportIndex = ComputeViewportIndexFromSplitscreenMode(px, resolution, rendererData.splitscreenMode);
    mat4 inverseProjectionView = viewportData[viewportIndex].inverseProjectionView;

    ivec2 depthSize = textureSize(uDepth, 0);
    ivec2 depthPx = ivec2((vec2(px) + 0.5) * vec2(depthSize) / vec2(resolution));
    float depth = texelFetch(uDepth, depthPx, 0).r;
    vec2 globalUV = (vec2(depthPx) + 0.5) / vec2(depthSize);
    vec2 viewportUV = GlobalUVToViewportUV(globalUV, viewportData[viewportIndex]);
    vec4 clip = vec4(viewportUV * 2.0 - 1.0, depth, 1.0);
    vec4 worldH = inverseProjectionView * clip;
    vec3 worldPosition = worldH.xyz / max(worldH.w, 1e-6);

    imageStore(OutputFogImage, px, vec4(worldPosition, 1.0));
}

void main() {
    ivec2 px = ivec2(gl_GlobalInvocationID.xy);
    ivec2 resolution = imageSize(OutputFogImage);
    if (px.x >= resolution.x || px.y >= resolution.y) return;

    uint viewportIndex = ComputeViewportIndexFromSplitscreenMode(px, resolution, rendererData.splitscreenMode);
    mat4 inverseProjectionView = viewportData[viewportIndex].inverseProjectionView;
    mat4 inverseProjection = viewportData[viewportIndex].inverseProjection;
    mat4 inverseView = viewportData[viewportIndex].inverseView;
    vec3 viewPos = viewportData[viewportIndex].viewPos.xyz;

    //float u_time = 0;

    // Ray origin
    vec3 origin = viewPos;

    // Ray direction
    vec2 globalUV = (vec2(px) + 0.5) / vec2(resolution);
    vec2 viewportUV = GlobalUVToViewportUV(globalUV, viewportData[viewportIndex]);
    vec3 dir = RayDirectionFromViewportUV(viewportUV, inverseProjection, inverseView);

    // World position (reconstruction from depth)
    ivec2 depthSize = textureSize(uDepth, 0);
    ivec2 depthPx = ivec2((vec2(px) + 0.5) * vec2(depthSize) / vec2(resolution));
    float depth = texelFetch(uDepth, depthPx, 0).r;
    vec4 clip = vec4(viewportUV * 2.0 - 1.0, depth, 1.0);
    vec4 worldH = inverseProjectionView * clip;
    vec3 worldPosition = worldH.xyz / max(worldH.w, 1e-6);

    // Scene distance
    //float sceneDist = length(worldPosition - viewPos);
    float sceneDist = dot(worldPosition - origin, dir);
    sceneDist = max(sceneDist, 0.0);
    sceneDist = min(sceneDist, MAX_FOG_DIST);

    vec3 accCol = vec3(0.0);
    float accAlpha = 0.0;

    // Offset starting distance (to hide banding)
    seed = uint(px.y * resolution.x + px.x) + uint(u_noiseSeed) * uint(px.x) * uint(px.y);
    float rand = random();
    float t0 = rand * dt;

    int fogTextureSize = textureSize(uNoiseVol, 0).x;
    float timeScroll = fract(u_time * timeScrollSpeed / float(fogTextureSize));
    float xMorph = fract(u_time * xMorphSpeed / float(fogTextureSize));
    float zMorph = fract(u_time * zMorphSpeed / float(fogTextureSize));
    float yScroll = fract(u_time * yScrollSpeed / float(fogTextureSize));

    // Misc constants
    vec3 dynamicOffset = fogSpeed * u_time;
    vec3 uvScale = vec3(noiseScaleXZ, noiseScaleY, noiseScaleXZ);
    float flashlightRadius = 10.0;
    float flashlightStrength = 0.5;
    float flashhlightOuterAngle = cos(radians(25.0));

    // Precompute dt-based mip (constant for the whole ray)
    float noisePeriodXZ = 1.0 / noiseScaleXZ;
    float noisePeriodY  = 1.0 / noiseScaleY;
    float noiseMipFromDt = ComputeNoiseMipFromDt(dt, fogTextureSize, noisePeriodXZ, noisePeriodY);

    for (int i = 0; i < NUM_STEPS + 0; ++i) {
        float t = dt * float(i) + t0;

        if (t >= sceneDist) break;

        // Distance-based mip: sharp near camera, blur far away
        float noiseMipFromDistance = ComputeNoiseMipFromDistance(t);

        // Optionally enforce at least the dt-driven mip to avoid aliasing
        float noiseMip = mix(noiseMipFromDistance, max(noiseMipFromDistance, noiseMipFromDt), clamp(u_noiseMipRespectDt, 0.0, 1.0));

        float noiseScaleMult = ComputeNoiseScaleMultiplier(t);
        vec3 uvScaleDynamic = uvScale / max(noiseScaleMult, 1e-6);

        float scaleMipBias = -log2(max(noiseScaleMult, 1e-6));
        noiseMip += scaleMipBias;
        float maxLevel2 = float(textureQueryLevels(uNoiseVol) - 1);
        noiseMip = clamp(noiseMip, max(u_noiseMinMip, 0.0), min(u_noiseMaxMip, maxLevel2));

        vec3 raySampleWorldPos = origin + dir * t;
        vec3 baseUV = fract((raySampleWorldPos + dynamicOffset) * uvScaleDynamic);

        vec3 nuv1 = baseUV;
        nuv1.x = fract(nuv1.x - xMorph + 0.1 + timeScroll);
        nuv1.z = fract(nuv1.z + zMorph + 0.1 + timeScroll);
        nuv1.y = fract(nuv1.y + yScroll);
        float d1 = textureLod(uNoiseVol, nuv1, noiseMip).r;

        vec3 nuv2 = baseUV;
        nuv2.x = fract(nuv2.x + xMorph);
        nuv2.z = fract(nuv2.z - zMorph);
        //nuv2.y = fract(nuv1.y - yScroll);
        nuv2.y = fract(baseUV.y - yScroll);
        float d2 = textureLod(uNoiseVol, nuv2, noiseMip).r;

        //float dens = mix(d1, d2, 0.5);
        //float ext = exp(-dens * dt);

        float dens = mix(d1, d2, 0.5);
        dens = max(dens - u_densityBias, 0.0) * u_densityScale;  // bias cuts low fog
        float ext = exp(-dens * dt);

        // Ambient fog
        float fadeAmbient    = clamp((t - nearFadeAmbient) / (farFadeAmbient - nearFadeAmbient), 0.0, 1.0);
        vec3 ambientFogColor = vec3(fadeAmbient);

        // Flashlight fog
        float fadeFlashlight = clamp((t - nearFadeFlashlight) / (farFadeFlashlight - nearFadeFlashlight), 0.0, 1.0);
        vec3 flashlightLightingSum = vec3(0.0);

        if (fadeFlashlight > 0.0) {
            // Flashlight term (sum 2 flashlights: player 0 and 1)

            for (int flashlightPlayerIndex = 0; flashlightPlayerIndex < 2; ++flashlightPlayerIndex) {

                vec3 flashlightPosition = viewportData[flashlightPlayerIndex].flashlightPosition.xyz;
                vec3 flashLightDir      = viewportData[flashlightPlayerIndex].flashlightDir.xyz;

                // Lower for non-current player flash light
                if (flashlightPlayerIndex != viewportIndex) {
                    flashlightPosition.y -= 0.4;
                }

                float flashlightModifer  = viewportData[flashlightPlayerIndex].flashlightModifer;

                // experimental new flashlight colors
                vec3 flashlightColor = GetFlashLightColor();

                float innerAngle = cos(radians(5.0 * flashlightModifer));

                vec3 d = flashlightPosition - raySampleWorldPos;
                float dist2 = dot(d, d);
                float invDist = inversesqrt(max(dist2, 1e-12));
                float dist = dist2 * invDist;
                vec3 toLight = d * invDist;

                // distance fall-off + strength
                float lightAttenuation = smoothstep(flashlightRadius, 0.0, dist) * flashlightStrength;

                // cone fall-off
                float spotFactor = smoothstep(flashhlightOuterAngle, innerAngle, dot(toLight, -flashLightDir));

                // extra smooth fade by distance
                float distanceFactor = clamp(1.0 - dist / flashlightRadius, 0.0, 1.0);
                spotFactor *= distanceFactor * distanceFactor;

                vec3 flashlightLighting = spotFactor * lightAttenuation * fadeFlashlight * flashlightModifer * flashlightColor;

                // Hack
                flashlightLighting *= 0.75;
                if (flashlightPlayerIndex != viewportIndex) {
                    flashlightLighting *= 50;
                }

                flashlightLightingSum += flashlightLighting;
            }
        }

        // Total in scattering at this step
        //vec3 insc = (ambientFogColor + flashlightLightingSum);
        //
        //// front-to-back composite
        //accCol += (1.0 - accAlpha) * insc;
        //accAlpha += (1.0 - accAlpha) * (1.0 - ext);

        // Total in scattering at this step
        vec3 stepScatter = (ambientFogColor + flashlightLightingSum) * (1.0 - ext);

        // front-to-back composite
        accCol += (1.0 - accAlpha) * stepScatter;
        accAlpha += (1.0 - accAlpha) * (1.0 - ext);

        t += dt;

        if (accAlpha >= 0.99) break;
    }

    //accCol *= 0.25;

    // Factor in fog color
    accCol *= FOG_COLOR;

    // Tone it down a bit
    //accCol *= 0.45;
    //accCol *= 15.45;

    accCol *= u_finalDampingFactor;

    //accCol *= 20;

    // Store it
    imageStore(OutputFogImage, px, vec4(accCol, accAlpha));
}
